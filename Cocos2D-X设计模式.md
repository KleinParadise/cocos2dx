### 1.管理者模式
在cocos2d-x中的TextureCache, SpriteFrameCache, AnimationCache和ShaderCache类都属于管理者模式。
这些管理者类一般被设计成单例类。这是因为管理者一般会采用key-value的形式来管理其它类的实例，每当需要获取一个管理者中的实例时，只需要提供一个惟一的键值字符
串就可以得到一个与之对应的惟一实例。如果允许存在多个管理者实例的话，那么每个管理者都会维护各自的key-value pairs。这样显然就不能通过键值字符串来获得惟一
对象实例了。
#### 优点
为一组相关的对象提供一个统一的全局访问点，同时可以提供一些简洁的接口来获取和操作这些对象。同时，使用此模式来缓存游戏中的常用资源，可以提高游戏运行时性能。
#### 缺点
继承单例模式的所有缺点

### 2.防御式编程模式
1. 使用do…while(0)检查指针的参数值;
2. 在变量使用的地方定义变量，在变量定义之后一定要保证其初始化
3. 使用const和assert宏来验证编程时的假设
#### 优点
提高代码质量，使得代码的健壮性和稳定性都有保障。
#### 缺点
造成代码的臃肿,同时也增加了代码的复杂度

### 3.中介者模式
CCDirector类除了应用了单例模式，还应用了中介者模式。它封装了Scheduler、ActionManager、TouchDispatcher、KeypadDispatcher和Accelerometer这五个对象的
交互。它使得这几个对象之间的交互不需要显式地相互引用，使其耦合度变低。当然更多的是使得我们游戏中的对象可以方便地与这些类进行交互，而不需要显式地引用这些类。
#### 优点
把多个同事对象的交互封装到一个中介者对象中，使得同事对象之间松散耦合，互不依赖。把交互控制变得集中，多对多变成了一对多
#### 缺点
容易造成中介者对象变成巨无霸类，维护和修改变得更加困难


### 4.委托模式
Cocos2d-x里面的CCMenu的响应事件，CCControlButton的响应事件，还有一大堆scheduler的实现，都采用了委托设计模式。它的实现细节就是采用了指向成员函数的指针。
#### 优点
业务与框架解耦;支持扩展和配置,可在运行状态下切换委托对象,灵活性高
#### 缺点
过度使用，容易导致职责分散，导致维护麻烦;采用接口的实现，由于使用了虚函数，所以性能上会有一点损失。(虚函数指针,查询虚函数列表性能消耗)

### 5.观察者模式
使用EventDispatcher的Custom Event来替代）一个目标对象可以注册多个观察者，当目标对象的状态改变的时候，可以通知观察者对象作出相应的响应。
#### 优点
使目标对象和观察者之间解耦,不必关心彼此的实现细节
#### 缺点
过度使用造成代码逻辑混乱,难维护
