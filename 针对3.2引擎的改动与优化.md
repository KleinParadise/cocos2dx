# Cocos2dx3.2简介

## Cocos2dx引擎系统总览
![GitHub Logo](/pic/pic_cocos_one.jpg)

### Cocos2dx帧循环

动画计算 -> 物理模拟 -> 逻辑更新 -> UI树遍历 -> 绘制 -> 交换缓冲区 -> 自动释放


### Cocos2dx内存管理机制
1. 通过retain()和release()来增加减少一个对象的引用计数，当引用计数为零时自动调用delete运算符删除对象并释放内存。
2. 使用autorelease()方法来声明一个对象指针为智能指针,并被加入到一个AutoReleasePool中。在每帧结束时会对AutoReleasePool中的对象进行一次release()操作,
也就是计数减一,达到自动回收的目的
3. 在AutoReleasePool队列中自定义一个AutoReleasePool的生命周期，当生命周期结束时会释放对象,并从队列中移除自己。这样是为了让那些生命周期不需要一帧的对象
尽快释放,避免在帧结束才释放从而使内存达到峰值。


### Cocos2dx新的渲染系统
1. 主线程的每一帧遍历UI树的每个元素时,不直接调用OpenGL ES进行绘制,而是将每个元素的绘制命令包装成RenderCommand对象放入绘制栈中,在遍历完所有元素后才从绘
制栈中拿出绘制命令进行绘制。
2. 绘制命令可以被重用,多个不同元素就可以使用相同的绘制命令进行组合。
3. 所有绘制命令被集中处理,所以可以做一些优化工作。比如相同命令类型,相同纹理及绘制参数可以合并成一次绘制,减少绘制次数,提高渲染性能。
4. 绘制栈在开始绘制时可以对绘制顺序进行重新排序，打破了UI树结构的绘制顺序。这相当于3D游戏中的Z值。
5. 可以通过不发送绘制指令达到减少不必要绘制调用。只对Spirite做了处理。

### Cocos2dx统一的事件分发器EventDispatcher
1. 不仅能处理系统提供的事件,还可以分发游戏中的自定义事件。
2. 可以将一个事件关联到一个UI元素,根据元素的绘制顺序计算一个优先级,即离屏幕越近的订阅者越能优先处理这个事件,保证事件分发器按照正确的UI顺序分发事件。
3. 将事件与一个Node元素关联,当这个元素被移出场景时,与其关联的所有订阅者的处理者会被全部移除,而不需要手动移除。

### Cocos2dx跨平台的lable
1. 使用开源的FreeType字体库来解析文字和生成纹理,这个可以获取每个字符的描述信息,不仅能通过着色器程序给每个文字添加不同特效(描边,加粗等),还能让多个文字共享一张纹理,提高绘制效率。
2. 统一了LableTTF,LableIBMFont,lableAtlas的接口
3. 缓存纹理,提高效率

### Cocos2dx新的数据结构
1. Vector<T>和Map<K,V>分别代替CCAarray和CCDictionary。实际就是对std::vector<T>,std::unordered map<K,V>的封装。
2. 与cococs2dx内存管理相结合。保证T,V都是Ref类型,以任何形式新加入容器中左值都会执行retain使引用计数加1,以任何形式从容器中移除左值都会执行release使引用计数减1。
3. 实现移动拷贝函数和移动赋值操作符,使用右值时减少了一些不必要的临时变量的生成和复制。
  
  
## 着色器功能扩充

### OpenGL ES 2.0渲染管线
1. 客户端程序通过调用OpenGL ES接口,将顶点,着色器程序,纹理以及其他GL状态参数传入GL服务端,然后调用绘制命令,GL便会对输入的图元逐一执行渲染管线的每个阶段,然后将每个像素的颜色值写入帧缓冲中,最后显示到屏幕上
2. 在整个渲染管线中,顶点着色器和片段着色器是可编程部分,而其他阶段只能使用一些固定的GL命令影响该阶段的执行。
3. 以photoshop的颜色叠加效果为模板,编写shader实现变色效果,使同一种资源呈现不同效果。
4. 标准的算法带有if-else判断或者三元表达式,对shader的效率有影响
5. 代码中优化为使用step或者clamp消除if-else分支。

### 效果实现
1. 白光效果
无视纹理原来的颜色,颜色统一设置为白色vec3(1.0),alpha值不变  
将受击的骨骼动画的所有皮肤在1-n帧内设置为白光效果,可以模拟出受击效果。

2. 叠加
算法为:(A为输入的顶点颜色,B为纹理的像素颜色信息)  
(B<128)?(2*A*B/255):(255-2*(255-A)*(255-B)/255) 

3. 正片叠底
算法为:(A为输入的顶点颜色,B为纹理的像素颜色信息)  
(A * B)/255

4. 变暗
算法为:(A为输入的顶点颜色,B为纹理的像素颜色信息)  
(B > A) ? A : B  
取A与B中当前通道颜色值较小的一个,整体会变暗


### 在地图中的应用
1. 系统启动后编译并预加载所有模式的shader,地图加载时根据配置的变色方案启用对于的shader,并传入具体的参数,包括颜色,透明度等等。
2. 在地图编辑器中配置每张地图图层的变色方案和具体参数,在加载地图中实现变色,仅实现单次变色
3. 实现同一场景中颜色的过渡效果。使用自定义action,动态修改shader中的uniform参数,实现同一场景的不同氛围。



## UI元素修改

### GlobalZOrder  
需求:A-B C-D为两套父子node关系,B随A移动、缩放、旋转,D随C移动、缩放、旋转.使渲染次序为A-C-D-B  
通过GlobalZOrder可以实现此需求,并且代价较小(每帧c++对小于1000个元素进行排序)  
cocos2dx对GlobalZOrder只在sprite进行了支持,其他元素需自行修改实现

### 不规则按钮处理
1. cocos2dx默认的触摸事件响应时按矩形进行判断
2. 部分按钮为不规则的矩形,且相互交错,按原有的矩形机制判断,会出现重叠。
3. 处理方法:在加载纹理时用RenderBuffer进行截图,然后判断每个像素的Alpha值,Alpha值大于阀值得区域认为是可点击区域。


## 碰撞检测和骨骼动画

### 碰撞检测流程
1. 模拟一个简单的物理世界,包含重力,速度和质量
2. 每帧在动画计算结束之后,再进行碰撞检测,核心部分是判断4种形式的物体在移动新位置后是否相交或者重叠.之后再根据碰撞结果进行位置修正。
3. 修正也有四种类型，线与线、线与矩形、矩形与线、矩形与矩形  
线与线:返回两条线的交点  
线与矩形:返回线的新位置  
矩形与线:向左碰撞,如果线的左边质量小于矩形的右边质量则矩形被挤进线内，则返回矩形新位置，否则被线修正回去。向右、向上、向下也是同理。  
矩形与矩形:矩形与矩形的修正类型矩形与线，也是通过质量判断，只不过修正的距离有区别。
4. 首先设置node的位置，然后修正挂在身上的所有框的位置，同时修正站在该框上面的所有框的位置，在修正框绑定的其他node的位置，依次递归。

### 骨骼合并
1. 因为主角的动画太多,如果只生成一个合集文件则加载时间非常长，而且有些动画不一定在当前用的到，会造成内存浪费。所以讲基础动作和技能动作进行拆分，保存为不同的纹理文件，并根据配置的数据进行动态加载合并。
2. 根据主角id,判断摇合并的动画是否存在列表中，不存在则加载，否则跳过，同时对纹理资源进行计数+1操作
3. 骨骼判断如果有了，就不再新加，但是需要记录下位置信息，因为动画是根据工程的骨骼位置记录下偏移量的。相同骨骼在不同工程的偏移量是不一样的，所有播放的时候需要更新位置。
4. 骨骼合并的时候，自身的纹理做合并。例如骨骼A里有5个纹理信息，新加的骨骼B里面有10个，那么新加的B里面纹理索引就是从6开始，而不是从0开始了，需要对B里面的所有动画做修改，修改它们的纹理索引。
5. 新加的动画，需要保存下每个骨骼的Zorder值,因为不同工程，可能zorder不一样，在播放动画的时候，bone::updateZorder的时候需要设置。例如A动画里，骨骼a是第7个创建的，那么他的zorder就是7，在B动画里，骨骼a是第50个创建的，那他就是50.如果不修正，会导致播放的时候，B工程a骨骼在其他的下面。
6. 对已创建的Armature对象做一次reloadData.其实就是让bone重新设置纹理数据。

### 骨骼挂载
1. 把Armature挂在一个特殊的节点ArmatureNode上,把ArmatureNode添加到另一个骨骼动画的bone上面。
2. 每个挂载子骨骼都有几种动画状态，如果只做成一个Armature,则动画总量是每个挂载子骨骼的几种动画状态的组合,比较庞大。
3. 挂载骨骼不由parent传下来的transfrom,而是用被挂载的bone给他传transform.而且等待被挂载的bone通知更新
4. 删除时必须先删挂载骨骼，再删被挂载骨骼。


## Android的修改

### 拆分so库
1. Cocos2dx将所有native代码的功能打包成单个so库,所以整个so库比较大
2. 由于项目对矩阵计算量大，而armeabi-v7a对矩阵算法进行了寄存器优化,因此对armeabi和armeabi-v7a分别进行了适配。因此如果要对so库进行补丁更新，文件会特别大，影响用户体验。
3. 根据Cocos2dx的功能划分和项目自己模块功能,拆分为多个so,最大的文件压缩之后差不多600k,两个架构下1M左右
4. 通过设计模式尽量将功能闭包在同一个so的代码范围内完成。复杂的耦合情况则通过观察者模式进行解耦。
5. 由于同时支持armeabi和armeabi-v7a两种架构，所以通过补丁机制下载的so是包含两个架构的。而加载函数System.load必须是文件的绝对路径,但我们无法准确获取到Android系统实际用哪个架构的so进行加载，如果我们加载不同架构的so会导致问题。为了解决这个问题，预置了两个libcpumodel.so,只提供一个函数，返回不同的字符串，通过这个来判断Android系统实际加载的so架构。

### Android包的资源包文件提取
为什么APK里面要放assets.zip?  
基于压缩效率、加密、安装速度三方面来考虑  
启动时如果将assets.zip拷贝到SDCard上，需要涉及md5校验之类的操作，每次启动增加CPU、物理存储I/O以及带来的事件成本  
assets中的zip文件不会再被压缩，而是直接存储，因此可以使用apk的文件句柄,修改zip库的读写函数,定位到zip在apk中偏移量进行操作,达到二次解压的效果。(第一次是从apk中访问zip文件的raw数据,第二次是从zip的raw数据中还原出源文件)

### Android补丁在线更新
1. 配置文件 + 单个文件判断下载的方案。根据更新文件池列表中的文件名,从本地保存的文件信息中获取MD5并进行对比，如有变化，则进行下载。
2. 对Android补丁的每个文件都进行zip和加密算法,同时修改后缀名保持跟原文件名一致，方便读取
3. 跨版本下载补丁的用户只需要下载该文件的最后一个版本
4. 避免修改本地文件而进行的外挂行为，可以在游戏运行中加载文件时进行计算md5,从而验证出文件是否被修改过。







