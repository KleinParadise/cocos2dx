# Cocos2dx3.2简介

### Cocos2dx引擎系统总览
![GitHub Logo](/pic/pic_cocos_one.jpg)

### Cocos2dx帧循环

动画计算 -> 物理模拟 -> 逻辑更新 -> UI树遍历 -> 绘制 -> 交换缓冲区 -> 自动释放


### Cocos2dx内存管理机制
1. 通过retain()和release()来增加减少一个对象的引用计数，当引用计数为零时自动调用delete运算符删除对象并释放内存。
2. 使用autorelease()方法来声明一个对象指针为智能指针,并被加入到一个AutoReleasePool中。在每帧结束时会对AutoReleasePool中的对象进行一次release()操作,
也就是计数减一,达到自动回收的目的
3. 在AutoReleasePool队列中自定义一个AutoReleasePool的生命周期，当生命周期结束时会释放对象,并从队列中移除自己。这样是为了让那些生命周期不需要一帧的对象
尽快释放,避免在帧结束才释放从而使内存达到峰值。


### Cocos2dx新的渲染系统
1. 主线程的每一帧遍历UI树的每个元素时,不直接调用OpenGL ES进行绘制,而是将每个元素的绘制命令包装成RenderCommand对象放入绘制栈中,在遍历完所有元素后才从绘
制栈中拿出绘制命令进行绘制。
2. 绘制命令可以被重用,多个不同元素就可以使用相同的绘制命令进行组合。
3. 所有绘制命令被集中处理,所以可以做一些优化工作。比如相同命令类型,相同纹理及绘制参数可以合并成一次绘制,减少绘制次数,提高渲染性能。
4. 绘制栈在开始绘制时可以对绘制顺序进行重新排序，打破了UI树结构的绘制顺序。这相当于3D游戏中的Z值。
5. 可以通过不发送绘制指令达到减少不必要绘制调用。只对Spirite做了处理。

### Cocos2dx统一的事件分发器EventDispatcher
1. 不仅能处理系统提供的事件,还可以分发游戏中的自定义事件。
2. 可以将一个事件关联到一个UI元素,根据元素的绘制顺序计算一个优先级,即离屏幕越近的订阅者越能优先处理这个事件,保证事件分发器按照正确的UI顺序分发事件。
3. 将事件与一个Node元素关联,当这个元素被移出场景时,与其关联的所有订阅者的处理者会被全部移除,而不需要手动移除。



